## 4-timer

In this example, we present an web app consisting of a timer that runs until a
specified duration elapses.  The duration can be controlled by the user using a
slider. The timer progress bar is adjusted as the user manipulates the slider.
Lastly, a button can be used to reset the timer.

In this example we will need to query the system for the current timestamp; we
will do this by defining a custom command (this will be explained in detail
below).

We begin as usual by describing the model and the set of messages describing the
possible user interactions.

The model keeps track of the point in time when the timer was last reset (or
started if it has never been reset), `started`; the current time, `now`, the
maximum duration allowed, `max`.

```ocaml
type model =
  {
    started: float;
    now: float;
    duration: float;
    max: float;
  }
```

The possible messages correspond to a periodic tick of the clock (the payload is
the timestamp of the tick), `Tick`; the user having reset the timer, `Reset`; a
message generated when receiving the current timestamp after resetting the
timer, `Restart`; and a message generated by manipulating the slider that
controls the duration of the timer.

```ocaml
type msg =
  | Tick of float
  | Reset
  | Restart of float
  | Range of float
```

Next, we look at the `view` function. We put together some labels, the progress
bar and the slider, as well as the reset button, which generates the `Reset`
message when clicked.

```ocaml
let view {started; now; duration; max} =
  let elapsed = now -. started in
  let progress = (* ... *) in
  let slider = (* ... *) in
  Vdom.div
    [
      Vdom.div [Vdom.txt_span "Elapsed time:"; progress];
      Vdom.div [Vdom.text (Printf.sprintf "%.1fs" (elapsed /. 1000.))];
      Vdom.div [Vdom.txt_span "Duration:"; slider];
      Vdom.div [Vdom.elt "button" ~a:[Vdom.type_button; Vdom.onclick (fun _ -> Reset)] [Vdom.text "Reset"]];
    ]
```

The progress bar is built out of a `progress` element. The maximum range of the
progress bar is given by `duration` (the current duration of the timer).

```ocaml
let progress =
  Vdom.elt "progress" ~a:[Vdom.float_attr "value" elapsed; Vdom.float_attr "max" duration] []
```

The slider is a `range` input field and it uses `max` (the maximum duration
allowed) and `duration` (the current duration of the timer). When the user
manipulates this input field, we generate a `Range` message.

```ocaml
let slider =
  Vdom.input
    ~a:[Vdom.oninput (fun s -> Range (float_of_string s));
        Vdom.attr "type" "range";
        Vdom.float_attr "min" 0.0;
        Vdom.float_attr "max" max;
        Vdom.float_attr "value" duration] []
```

Next comes the `update` function. But first, we will take a closer look at the
mechanism used to retrieve the current timestamp from the browser, as well as
getting a periodic tick from it. For this, we use _custom commands_,

```ocaml
type 'msg Vdom.Cmd.t +=
  | Now of (float -> 'msg)
  | Every of int (* msec *) * (float -> 'msg)
```

The command `Now` can be used to query for the current timestamp from the
browser. The command `Every` can be used to continuously generate a message
every the given number of milliseconds. They are defined and registered as
follows:

```ocaml
let () =
  let f ctx = function
    | Now msg ->
        Vdom_blit.Cmd.send_msg ctx (msg (Js_browser.Date.now ()));
        true
    | Every (d, msg) ->
        let _ =
          Js_browser.Window.set_interval Js_browser.window
            (fun () -> Vdom_blit.Cmd.send_msg ctx (msg (Js_browser.Date.now ()))) d
        in
        true
    | _ ->
        false
  in
  Vdom_blit.register (Vdom_blit.cmd {f})
```

Now we are ready to study the `update` function. We handle each one of the
messages.

- `Reset`, it means the user reset the timer. We query the current timestamp
  using the `Now` command. Then the timestamp is received, a `Restart` message
  will be generated.

- `Restart`, we have received the current timestamp from the browser and we can
  now do the actual restart of the timer.

- `Tick`: this message is generated periodically, and its payload is the current
  timestamp. We update the model accordingly.

- `Range`: this message is generated when the user manipulates the slider that
  controls the duration of the timer. The payload is the new duration. The model
  is updated accordingly.

The code is a simple translation of the above specifications:

```ocaml
let update model = function
  | Reset ->
      Vdom.return ~c:[Now (fun now -> Restart now)] model
  | Restart now ->
      Vdom.return {model with started = now; now}
  | Tick now ->
      Vdom.return {model with now}
  | Range duration ->
      Vdom.return {model with duration}
```

Finally, we tie the knot by defining the app and rendering it in the body of the
current document. Note that we start the timer by simulating an initial "Reset"
(by calling the `Now` command), and we start a periodic tick by calling the
`Every` command (which will deliver the `Tick` messages).

```
let init =
  let duration = 60. in
  let max = 120. in
  let c = [Now (fun now -> Restart now); Every (100, (fun now -> Tick now))] in
  Vdom.return ~c
    {
      started = 0.0;
      now = 0.0;
      duration = duration *. 1000.;
      max = max *. 1000.;
    }

let _ =
  let app = Vdom.app ~init ~update ~view () in
  let container = Js_browser.Document.body Js_browser.document in
  Vdom_blit.dom (Vdom_blit.run ~container app)
```
